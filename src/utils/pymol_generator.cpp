#include "utils/pymol_generator.h"
#include "utils/file.h"
#include "utils/logger.h"
#include "utils/pdb_parser.h"
#include <sstream>
#include <iomanip>

namespace gangsta {
namespace utils {

PyMolGenerator::PyMolGenerator() 
    : molecule1(), molecule2(), alignedMolecule1(), result() 
{
}

void PyMolGenerator::setMolecules(const core::Molecule& molecule1, 
                                 const core::Molecule& molecule2,
                                 const core::Molecule& alignedMolecule1) 
{
    this->molecule1 = molecule1;
    this->molecule2 = molecule2;
    this->alignedMolecule1 = alignedMolecule1;
}

void PyMolGenerator::setAlignmentResult(const algorithm::AlignmentResult& result) 
{
    this->result = result;
}

bool PyMolGenerator::generateScript(const std::string& outputPath, const std::string& pdbOutputPath) 
{
    // First generate the aligned PDB file
    if (!generateAlignedPDB(pdbOutputPath)) {
        Logger::getInstance().error("Failed to generate aligned PDB file");
        return false;
    }
    
    // Generate the PyMOL script content
    std::string scriptContent = generateScriptContent(pdbOutputPath);
    
    // Write the script to file
    File scriptFile;
    if (!scriptFile.open(outputPath, std::ios::out)) {
        Logger::getInstance().error("Failed to open output file: " + outputPath);
        return false;
    }
    
    if (!scriptFile.write(scriptContent)) {
        Logger::getInstance().error("Failed to write to output file: " + outputPath);
        return false;
    }
    
    Logger::getInstance().info("PyMOL script generated: " + outputPath);
    return true;
}

std::string PyMolGenerator::generateScriptContent(const std::string& pdbPath) 
{
    std::stringstream ss;
    
    // Script header with instructions
    ss << "# PyMOL script for visualizing GANGSTA+ alignment\n";
    ss << "# Generated by GANGSTA+ modular edition\n\n";
    
    // Load PDB file
    ss << "# Load aligned structures\n";
    ss << "load " << pdbPath << "\n\n";
    
    // Add color scheme
    ss << "# Set color scheme\n";
    ss << generateColorScheme() << "\n";
    
    // Add visualization settings
    ss << "# Set visualization style\n";
    ss << generateVisualizationSettings() << "\n";
    
    // Add alignment visualization
    ss << "# Show alignment\n";
    ss << generateAlignmentCommands() << "\n";
    
    // Add information text
    ss << "# Add alignment information\n";
    ss << "set text_color, black\n";
    ss << "set label_size, 20\n";
    ss << "set label_position, (0, 0, 0)\n";
    ss << "set label_font_id, 7\n";
    ss << "label position=(0, 0, 0), \"Aligned length= " << result.getAlignedCount() 
       << ", RMSD= " << std::fixed << std::setprecision(2) << result.getRMSD() 
       << ", Score= " << std::fixed << std::setprecision(5) << result.getScore() << "\"\n\n";
    
    // Set view
    ss << "# Set view\n";
    ss << "set_view (\\\n";
    ss << "    1.000000, 0.000000, 0.000000, \\\n";
    ss << "    0.000000, 1.000000, 0.000000, \\\n";
    ss << "    0.000000, 0.000000, 1.000000, \\\n";
    ss << "    0.000000, 0.000000, -50.000000, \\\n";
    ss << "    0.000000, 0.000000, 0.000000, \\\n";
    ss << "    40.000000, 100.000000, -20.000000)\n\n";
    
    return ss.str();
}

bool PyMolGenerator::generateAlignedPDB(const std::string& outputPath) 
{
    // We need to create a PDB file that contains both the original molecule2
    // and the aligned version of molecule1
    
    // First, rename the molecules to avoid conflicts
    core::Molecule mol1 = alignedMolecule1;
    core::Molecule mol2 = molecule2;
    
    mol1.setName("aligned_" + molecule1.getName());
    
    // Use the PDB parser to generate PDB content
    PDBParser parser;
    
    // Create the PDB content for each molecule
    std::string pdbContent1 = parser.moleculeToPDBContent(mol1);
    std::string pdbContent2 = parser.moleculeToPDBContent(mol2);
    
    // Combine the PDB content
    std::string combinedPDBContent = pdbContent1 + "END\n" + pdbContent2;
    
    // Write to file
    File outputFile;
    if (!outputFile.open(outputPath, std::ios::out)) {
        Logger::getInstance().error("Failed to open output file: " + outputPath);
        return false;
    }
    
    if (!outputFile.write(combinedPDBContent)) {
        Logger::getInstance().error("Failed to write to output file: " + outputPath);
        return false;
    }
    
    Logger::getInstance().info("Aligned PDB file generated: " + outputPath);
    return true;
}

std::string PyMolGenerator::generateColorScheme() const 
{
    std::stringstream ss;
    
    // Define custom colors
    ss << "# Define custom colors\n";
    ss << "set_color mol1_color, [0.2, 0.5, 0.8]  # blue for molecule 1\n";
    ss << "set_color mol2_color, [0.8, 0.2, 0.2]  # red for molecule 2\n";
    ss << "set_color helix_color, [1.0, 0.6, 0.6]  # pink for helices\n";
    ss << "set_color sheet_color, [0.6, 0.6, 1.0]  # light blue for sheets\n";
    ss << "set_color loop_color, [0.8, 0.8, 0.8]  # grey for loops\n\n";
    
    // Color the molecules
    ss << "# Color molecules\n";
    ss << "color mol1_color, aligned_" << molecule1.getName() << "\n";
    ss << "color mol2_color, " << molecule2.getName() << "\n\n";
    
    // Color by secondary structure
    ss << "# Color by secondary structure\n";
    ss << "color helix_color, ss h\n";
    ss << "color sheet_color, ss s\n";
    ss << "color loop_color, ss l\n";
    
    return ss.str();
}

std::string PyMolGenerator::generateVisualizationSettings() const 
{
    std::stringstream ss;
    
    // Set general display options
    ss << "# Set general display options\n";
    ss << "bg_color white\n";
    ss << "set depth_cue, 0\n";
    ss << "set ray_shadows, 0\n";
    ss << "set ray_trace_mode, 1\n";
    ss << "set antialias, 2\n\n";
    
    // Set molecule representation
    ss << "# Set molecule representation\n";
    ss << "hide everything\n";
    ss << "show cartoon\n";
    ss << "set cartoon_fancy_helices, 1\n";
    ss << "set cartoon_transparency, 0.2\n";
    ss << "set cartoon_side_chain_helper, on\n\n";
    
    // Show aligned residues
    ss << "# Show aligned residues\n";
    ss << "select aligned, aligned_" << molecule1.getName() << " and ";
    
    // Create a selection of aligned residues
    const auto& alignedPairs = result.getAlignedPairs();
    if (!alignedPairs.empty()) {
        ss << "(";
        
        bool first = true;
        for (const auto& pair : alignedPairs) {
            if (!first) {
                ss << " or ";
            }
            
            // Get residue number from alpha carbon index
            int residueNumber = 0;
            if (pair.first >= 0 && 
                pair.first < static_cast<int>(alignedMolecule1.getAlphaCarbons().size())) {
                residueNumber = alignedMolecule1.getAlphaCarbons()[pair.first].getResidueNumber();
                ss << "resi " << residueNumber;
                first = false;
            }
        }
        
        ss << ")";
    } else {
        ss << "none";
    }
    
    ss << "\n";
    ss << "show sticks, aligned\n";
    ss << "show spheres, aligned and name CA\n";
    ss << "set sphere_scale, 0.5\n\n";
    
    // Hide hydrogens
    ss << "# Hide hydrogens\n";
    ss << "hide (hydro)\n";
    
    return ss.str();
}

std::string PyMolGenerator::generateAlignmentCommands() const 
{
    std::stringstream ss;
    
    // Show aligned pairs
    ss << "# Show aligned pairs\n";
    const auto& alignedPairs = result.getAlignedPairs();
    
    for (const auto& pair : alignedPairs) {
        // Get residue numbers from alpha carbon indices
        int residueNumber1 = 0;
        int residueNumber2 = 0;
        
        if (pair.first >= 0 && 
            pair.first < static_cast<int>(alignedMolecule1.getAlphaCarbons().size())) {
            residueNumber1 = alignedMolecule1.getAlphaCarbons()[pair.first].getResidueNumber();
        }
        
        if (pair.second >= 0 && 
            pair.second < static_cast<int>(molecule2.getAlphaCarbons().size())) {
            residueNumber2 = molecule2.getAlphaCarbons()[pair.second].getResidueNumber();
        }
        
        ss << "distance alignment, aligned_" << molecule1.getName() << " and resi " << residueNumber1 
           << " and name CA, " << molecule2.getName() << " and resi " << residueNumber2 << " and name CA\n";
    }
    
    // Set distance visualization
    ss << "color gray60, alignment\n";
    ss << "set dash_gap, 0\n";
    ss << "set dash_width, 1\n";
    ss << "set dash_radius, 0.05\n";
    
    return ss.str();
}

} // namespace utils
} // namespace gangsta